# C++ 笔记

## MingGW和CLion配置

> 工具有很多, 例如: 
>
> 1. 安装mingw或者cygwin ,  
> 2. 安装vscode , Clion 或者 codeblock 
>
> 具体配置可以上网搜.(**我用的是MinGW + Clion**)

**MinGW安装**

[下载地址]:https://sourceforge.net/projects/mingw-w64/

进入上方页面后往下滑, 下载如下安装包: 

![image-20230807074919575](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807074919575.png)





**Clion安装和配置**

直接搜索Clion , 下载安装即可(Clion是付费的)

安装完成后直接点击 `New project`, 配置如下:

![image-20230807054422296](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807054422296.png)

之后像下面这样配置编译器就可以了. 

![image-20230807075737534](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807075737534.png)





## 第一个C++ 程序

配置好后, 直接创建项目就行. 具体步骤就不做介绍了.

此处简单认识一下c++ 就可以了

```c++
#include <iostream>       // 预编译指令, 引入头文件iostream
using namespace std;      // 使用默认的std命名空间, 这样就不用写 std:: 了
int main(){
    int a;        // 定义整型变量
    a = 10 ;
    cout << "Hello , World!" << endl;    // c out 打印   , endl 换行.
    return 0;
}
```



## 命名空间

### 使用namespace

```
namespace{
// 定义变量, 函数, 类型, 对象 ...
}
```



### 命名空间的嵌套定义

也就是在一个命名空间中, 再定义一个命名空间

```c++
namespace A{
		int a = 10
		name space B {
			int a = 20
		}
}

// 调用的时候
```





### 命名空间成员访问

```
使用作用域操作符    ::
格式:
空间名 :: 成员
```

** **

> 
>
> **`注意:`**
>
> **`命名空间的定义必须是全局定义!!!`** , 不能在函数中定义, 否则报错.





### 命名空间的生命和分开实现

> 为了避免命名空间过长,  影响可读性, 可以将在 `.h`文件中声明命名空间和里面的一些属性(例如:函数, 变量) .  之后在 `.cpp`文件中进入具体的定义.

示范如下:

> 创建 test.h 文件

![image-20230807081303785](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807081303785.png)

Name命名为 `test`

![image-20230807081558760](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807081558760.png)

之后就可以声明 **命名空间, 函数 之类的了**

```c++
//
// Created by 2892706668 on 2023/8/7.
//

#ifndef C__PROGRAM_TEST_H
#define C__PROGRAM_TEST_H

#endif //C__PROGRAM_TEST_H

// 声明一个命名空间
namespace MySpace
{
    // 声明函数
    void func1();
    void func2(int);
}

```







> 下面创建  test.cpp 文件

![image-20230807081912444](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807081912444.png)

文件内容:

````c++
//
// Created by 2892706668 on 2023/8/7.
//

// 为了使用count , 添加如下两条语句
#include <iostream>
using namespace std;

// 下面调用test.cpp文件中的 func1 和 func2 函数
#include "test.h"        // 导入所需文件
void MySpace::func1() {
    cout << "void MySpace::func1()" << endl;
}

void MySpace::func2(int x) {
    cout << "void MySpace:: func2()" << x << endl;
}
````



下面我们在`main.cpp(创建项目时自动生成的, 也可以自己创建一个)`文件中 对 `test.cpp`文件的函数进行调用, `mai.cpp` 文件内容容下: 

```c++
#include <iostream>
using namespace std;
#include "test.h"        // 注意: 此处调用的是 .h文件
int main() {
    cout << "Hello, World!" << std::endl;
    MySpace::func1();
    MySpace::func2(100);
    return 0;
}
```

结果如下: 

![image-20230807084347741](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807084347741.png)





### 命名空间的别名

```c++
#include <iostream>
using namespace std;         

namespace veryLonName{
    void func3(){
        cout << "Hello veryLonName"  <<  endl;
    }

};

int main() {
    namespace shortname = veryLonName;
    shortname::func3();

    return 0;
}
```





## 引用

### 引用的使用和注意事项

> 1. 引用可以看作 **一个已经定义的变量的别名**
>
> 2. 语法 : `被引用的变量的数据类型&别名 =  变量`
>
>    **注意:**
>
>    1.  符号 &  起到标识的作用, 不是求地址运算的
>    2. 必须在声明引用变量时进行初始化(也就是一定要**赋值)** , 除非是在 **结构体**中.
>    3. 引用初始化后不能引用其他的变量, 但是可以用其他的变量赋值. 
>    4. 不能有NuLL应用 , 必须保证应用适合一块合法的存储单元关联的.

```c++
#include <iostream>
using namespace std;

void test10()
{
    int a = 10;
    int&b = a ;     //给a取个别名叫b
    cout << "a:" << a <<endl;
    cout << "b:" << b << endl;


    // 给 b 重新赋值, 操作b就相当于操作a  , 
    b = 100;
    cout << "a:" << a << endl;
    cout << "b: " << b << endl;  // 最终a , b都被重新赋值.

    // 一个变量可以有n个别名
    int& c= a;
    cout << "a:" << a << endl;
    cout << "c:" << c << endl;


    // a, b , c的操作地址都是一样的
    cout << "a:" << &a << endl;
    cout << "b:" << &b << endl;
    cout << "c:" << &c << endl;
}

int main() {
    test10();
    return 0;
}

```





### 引用的本质和内存占用

1. 

**C++的引用的本质就是在C++ 内部实现一个常指针**

```
Type&ref = val ;      // 其实内部实现的是 Type * const ref = &val;
```



2. 应用占用的内存空间

   C++ 编译器在编译过程中使用常指针作为引用的内部实现, 因此 **引用所占的空间大小于指针相同**, 只是引用过程是编译器内部实现的, 用户看不见而已.





验证引用所占用的空间的大小:

```c++
#include <iostream>
using namespace std;

// 用结构体来验证引用所占内存空间
struct test
{
    int & a;      // 64位计算机上, 一个指针就是 8个字节.
    int & b;      // 此处有两个指针对应 16 个字节.
};

int main() {
    cout << sizeof (struct test) << endl;  // 预计结果为16
    return 0;
}
```





`sizeof` 的确可以查看变量大小, 但是要慎用. 在C++ 中, `sizeof` 确定的是最最初始的值, 然后将其转化为ASCII码.对应的值.

```c++
#include <iostream>
using namespace std;


struct test
{
    int & a;      // 64位计算机上, 一个指针就是 8个字节.
    int & b;      // 此处有两个指针对应 16 个字节.
};

int main() {

    int *x;
    cout << "机器对应: "<<  sizeof(x) << endl; // 如果结果是8那么机器和编译器都是64位的.

    //
    float ch = 'a';
    float & p = ch;  // 预计结果为4
    cout << sizeof(p) << endl;   // 输出结果等价于: sizeof('a');

    return 0;
}
```



> **注意:**
>
> 有些地方说引用不占用内存空间, 那是因为 一些人的 **编译器是被优化过的**. 
>
> 如果编译器没有被优化, 那么引用所占用的内存空间的大小就等于指针所占内存空间.



### 引用作为函数的形参

```c++
#include <iostream>
using namespace std;


// 定义一个结构体
typedef struct Teacher
{
    char name[32];
    int age;

}Teacher;

// 创建函数引用结构体
void useteacher(Teacher &t)
{
    t.age = 10;
}

// 上方的函数等价于
//void useteacher(Teacher* const t)
//{
//    cout << t -> age << endl;
//    t->age = 33;
//}




int main() {
    Teacher a;
    a.age = 30;
    useteacher(a);
    // 上一行中的a如果是指针, 那么久等价于下一行
//    useteacher(&a)        // 将指针a传过去. 
    cout << a.age  << endl;


    return 0;
}
```



## 内联函数

在C语言中, 一些段短并且执行频繁的计算可以被写成宏, 而不是写成函数. 这样做是为了执行效率, 宏可以避免函数调用的开销, 这些都是由预处理完成的.

**宏的实现是一个文本替换的过程, 如果一些表达式比较复杂时, 可能会出错!!!**

**内联函数**既可以保证像宏那样方便, 有很安全不容易出错, 同时内联函数可以像一般函数一样能够在类里面访问自如.

```C++
// 内联函数举例
inline int func(int x, int y)
{
  return x + y 
}
```

内联函数其实就是在普通的函数前面添加上 `inline` . 

**注意:** 

1. 函数体必须和声明结合在一起, 否则实现的就不是内联函数, 而只是一个普通的函数.

2. 如果出现一下几种情况, 编译器也会将内联函数看做普通的函数来编译

   > 1. 存在任何形式的循环语句
   > 2. 存在过多的条件判断语句
   > 3. 函数体过于庞大
   > 4. 对函数进行取址操作.

2. 编译器会自己检查传入到内联函数中的参数类型是否正确, 这保证了出入类型的正确性.

3. 内联函数在最终生成的代码中是没有定义的, **内联函数的作用域只在其所在文件中**.

   



## 函数的默认参数



1. 默认参数都是放在最后的, 如果某个参数不是默认参数, 那必须放在前面.

2. 当某个函数既有默认参数, 又有必传参数的时候, 一定要给必传参数传参, 否则会报错. 

3. 如果已经 **声明了某个函数的默认参数**, 那么在实现的时候 **不用写默认参数了**, 填写后反而会报错. 正确示例如下:

   ```c++
   #include <iostream>
   using namespace std;
   
   // 声明一个带默认参数的函数
   int func1(int a = 10, int b = 11);
   
   // 对上方的函数进行定义
   int func1(int a,int b)
   {
       cout << a + b << endl;
       return a + b;               // 函数一定要有return, 否则报错.
   }
   
   int main() {
       func1();
       return 0;
   }
   ```

   



## 函数重载(Function Overload)

### 函数重载的定义和使用

用 **同一个函数名** 定义了不同的函数, 说白了就是同一个函数名, 但是带的参数不一样, 有的带了参数, 有的没带参数. 尽管函数名相同, 但是在C++中,  编译器会认为它们是不同的函数.



**函数重载条件**

> 满足一下条件, 我们可以用函数重载而不冲突:
>
> 1. 同一个作用域
> 2. 参数个数不同
> 3. 参数类型不同
> 4. 不同参数的顺序不同(比如 :  `int x = 10 , char y ` 和 `int y = 10, char x`)
>
> ```c++
> // 示例代码如下:
> void func(){};
> void func(int x) {};
> void func(char x){};
> void func(int x, int y){};
> void func(int x, char y){};
> void func(char y, int x){};
> 
> // 以上函数在C++ 中是不同的.
> ```



### 函数重载的原理

**本质上就是编译器造成的**

1. 编译器在将我们的程序进行编译完成后, 会将变量和函数变成一个个的符号, 存放这些符号的表成为符号表. 可以向下面这样在`终端`中编译文件, 生成 `.o`这种二进制文件, 查看符号表:

   ```
   g++ -c main.cpp
   nm main.o
   ```

   结果如下所示:

   ![image-20230807135044276](https://raw.githubusercontent.com/QDGSCLOUD/BJYH_picture/main/image2/image-20230807135044276.png)



如果写了重载的函数. 比如 `func `, C++ 的编译器是 `g++` , **编译器根据, 函数的参数个数,参数类型, 顺序 等生成不同的字母符号, 从而区分函数, 实现函数重载**. 



## 类和对象

> 1. **类是抽象的, 对象是具体的.**
> 2. 对象可以通过 **实例化** 类得到



### 类的定义

类是由**变量(属性)**和**函数(方法**)组成的

```c++
// 格式如下:
class 类名
{
访问控制符:      // 访问控制符有三种: public private , protected
		成员变量;  // 属性
		成员方法; // 方法
}
```



### 对象的实例化

1. 普通对象的实例化

   ```
   CAnimal cat ;           //  cat 就是一个具体的对象
   ```

2. 使用数组实例化多个普通对象

   ```
   //格式: 类名 数组名[数组长度];
   CAnimal cats[10];
   ```

   

3. 定义一个指针变量

   ```
   // 格式:     类名 *对象名称
   CAnimal *cat       // *cat 就是一个指针变量, 可以指向一个CAnimal的实例化对象
   ```

   

> **注意:**
>
> 指针变量本质上还是指针,  指针变量不是类的实例化对象.
>
> 说白了, 定义了一个 **类**类型的指针变量根本没有实例化对象

```C++
#include <iostream>
using namespace std;
#include "Cstring";

// 声明一个类
class CAnimal
{
public:
    //属性
    char name[32];   // 名字
    int age ;        // 年龄

    // 方法
    void fei_voice (const char *voice)      // 描述动物的叫声
    {
        cout << name << voice << endl;
    }

};



int main() {
    CAnimal cat;
    CAnimal cats[10];
    CAnimal *p;
    p = &cat ;
    cat.age = 1;
    cout << cat.age << endl;

    // 对于指针变量来说
    p->age = 11;
    cout << p->age << endl;

    memset(cat.name,0,sizeof (cat.name));   // 将cat.name 前 n 个都化为 0
    strcpy(cat.name,"xiaohuamao");           // 将后面的字符复制给 cat.name
    cat.fei_voice("miao miao");
    cout << cat.name << endl;

    return 0;
}

```



### 访问控制符

> 一共三种, 分别为:  public, private , protected
>
> public : 修饰成员变量和函数, 在类的内部和外部都可以被访问到
>
> private:  修饰成员变量和函数只能在类的内部被访问.
>
> protected:  修饰成员变量和函数只能在类的内部被访问.

**范例:**

```c++
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

using namespace std;

class Teacher
{
public:
    char name[32];

    void set_age(int age)  // 设置下方 _age属性
    {
        if((age > 200) || (age < 0))
        {
            cout << "age error" <<endl;
            return ;
        }

        // 如果上方成立, 那么, 下面的这两行就不会执行了
        cout << "void set_age(int age)" << endl;
        _age = age;
    }

    int get_age()      // 设置函数, 得到私有的_age
    {return _age;}


private:
    int _age;
    char _sex;    // 私有属性习惯前面用 短下划线 _

};


int main() {
    Teacher t;
    strcpy(t.name,"wangwu");
    cout << t.name << endl;
    t.set_age(30);                      // 先设置属性, 在访问.
    cout << t.get_age() << endl;
    return 0;
}

```





### 面向对象

> 面向对象的三大特点:
>
> 1. 封装
> 2. 继承
> 3. 多态



#### 封装

> 说白了就是三点:
>
> 1. 将变量(属性)和函数(方法)合成一个相对独立的整体
> 2. 尽量隐藏对象的内部细节
> 3. 对变量和函数进行访问控制, 保证数据的安全性



##### 实例

1. 编写一个程序求立方体的体积

```c++
#include <iostream>
using namespace std;

class Box {

public:
    // 声明方法 , 注意此处 不是定义方法, 只是声明.
    bool set_len(int len);
    bool set_w(int w);
    bool set_h(int h);

    int get_len();
    int get_w();
    int get_h();

    int get_s();
    int get_v();


private:
    int _len ;
    int _w ;
    int _h ;
    int _s ;
    int _v;


};

// 在类的外部定义类
bool Box::set_len(int len) {
    if (len <= 0 || len > 100){
        cout << "len error" <<endl;
        return false;
    };
    _len = len ;
    return  true ;

}

bool Box::set_w(int w) {
    if(w <= 0 || w>100){
        cout << "w error" << endl;
        return false ;
    };
    _w = w;
    return true ;
}

bool Box::set_h(int h) {
    if(h<= 0 || h>200){
        cout << "h error"  << endl;
        return false;
    };
    _h = h;
    return true;
}


int Box::get_len() {
    return _len;
}

int Box::get_w(){
    return _w;
}

int Box::get_h() {
    return _h;
}

int Box::get_s() {
    _s = _len * _w;
    return  _s;
}

int Box::get_v() {
    _v = _len * _w * _h;
    return _v ;
}



int main() {
    Box b;
    b.set_len(10);
    b.set_w(10);
    b.set_h(10);

    cout << b.get_s() << endl;
    cout << b.get_v() << endl;
    return 0 ;
};

```



**上方的Box类的分开实现**

上方 实例 可以被分成三部分.

1. 用来声明类的 `.h` 文件 (文件名一般为类名的大写)
2. 用来实现类的 `.cpp`文件
3. 用来调动类的 `.cpp` 文件

> Box.h  声明
>
> ```
> 
> #ifndef C__PROGRAM_BOX_TESTSQUIRE_H
> #define C__PROGRAM_BOX_TESTSQUIRE_H
> 
> #endif //C__PROGRAM_BOX_TESTSQUIRE_H
> 
> // 声明 Box 类.
> class Box {
> 
> public:
>     // 声明方法 , 注意此处 不是定义方法, 只是声明.
>     bool set_len(int len);
>     bool set_w(int w);
>     bool set_h(int h);
> 
>     int get_len();
>     int get_w();
>     int get_h();
> 
>     int get_s();
>     int get_v();
> 
> 
> private:
>     int _len ;
>     int _w ;
>     int _h ;
>     int _s ;
>     int _v;
> 
> 
> };
> 
> ```
>
> 



> Box.cpp 实现类
>
> ```
> #include <iostream>
> #include "Box.h"
> 
> using namespace std;
> 
> // 在类的外部定义类
> bool Box::set_len(int len) {
>     if (len <= 0 || len > 100){
>         cout << "len error" <<endl;
>         return false;
>     };
>     _len = len ;
>     return  true ;
> 
> }
> 
> bool Box::set_w(int w) {
>     if(w <= 0 || w>100){
>         cout << "w error" << endl;
>         return false ;
>     };
>     _w = w;
>     return true ;
> }
> 
> bool Box::set_h(int h) {
>     if(h<= 0 || h>200){
>         cout << "h error"  << endl;
>         return false;
>     };
>     _h = h;
>     return true;
> }
> 
> 
> int Box::get_len() {
>     return _len;
> }
> 
> int Box::get_w(){
>     return _w;
> }
> 
> int Box::get_h() {
>     return _h;
> }
> 
> int Box::get_s() {
>     _s = _len * _w;
>     return  _s;
> }
> 
> int Box::get_v() {
>     _v = _len * _w * _h;
>     return _v ;
> }
> 
> 
> ```
>
> 



> main.cpp  调用类
>
> ```
> #include <iostream>
> using namespace std;
> #include "Box.h"
> 
> int main() {
>     Box b;
>     b.set_len(10);
>     b.set_w(10);
>     b.set_h(10);
> 
>     cout << b.get_s() << endl;
>     cout << b.get_v() << endl;
>     return 0 ;
> };
> 
> ```
>
> 



##### 无参构造函数

> 在类里面的用来处理对象的初识化的一种函数, 不需要用户调用, 在建立对象的时候会自动执行. 

定义构造函数:

1. C++ 中构造函数与类名相同
2. 构造函数的参数可有可无
3. 构造函数没有任何返回类型的声明

4. 构造函数放在`public`中, 而不是`private` 中

```c++
// 示例:
#include <iostream>
using namespace std;

// 定义一个Box类
class Box {
public:

    // 下面是个无参构造函数
    Box(){
        cout << "Box()" <<endl;

        // 初始化私有变量
        _len = 10;
        _w = 10;
        _h = 10;
    }


    // 实例化一些函数
    int get_len(){return _len;}
    int get_w(){return _w;}
    int get_h(){return _h;}

private:
    int _len;
    int _w;
    int _h;

};




int main(){
    Box box1;
    Box x[4];
    // Box c();     // 这不是实例化对象, 而是在声明函数, 函数名为c , 参数为空. 不要这样写 , 啥也没返回

    // 打印初始化的  _len, _w , _h
    cout << box1.get_len() << endl;
    cout << box1.get_w() << endl;
    cout << box1.get_h() << endl;

    return 0;
}
```





##### 有参构造函数

```c++
#include <iostream>
using namespace std;

// 定义一个Box类
class Box {
public:

    // 下面是个有参构造函数
    Box(int len, int w , int h){  // 如果传入三个参数就调用这个构造函数.
        cout << "I have three param" <<endl;

        // 初始化私有变量
        _len = len;
        _w = w;
        _h = h;
    }

    // 下面是有参和无参混合的构造函数 ,  如果传入连个参数就调用这个构造函数.
    Box(int len , int w ){
        cout << "I have mixed constructor" << endl;
        _len = len;
        _w = w;
        _h = 10 ;
    }


    // 实例化一些函数
    int get_len(){return _len;}
    int get_w(){return _w;}
    int get_h(){return _h;}

private:
    int _len;
    int _w;
    int _h;

};




int main(){
    Box parambox(10,20,30);  // 此处实例化对象的时候就要传入值

    Box twoparabox(10,20);


    return 0;
}
```



> 注意:
>
> 养成好习惯 , 平时在写 **类** 的时候 , 自己都要手动的写上构造函数,  别嫌麻烦.



##### 初始化成员列表之构造函数

```c++
#include <iostream>
using namespace std;


class Eterbox{
public:
    int x;

    // 生成一个构造函数
    Eterbox(int a){
        x = a;
    }

};


// 定义一个Box类
class Box {
public:
    Box(int len , int w ):_len(len),_w(w),p(_len),sum(100), eterbox(10)     //  这里的赋值有下方的赋值时等价的.  p是引用, 要进行初始化
    {
        cout << "I have mixed constructor" << endl;
       /*

        _len = len;
        _w = w;

        */
    }

    // 第二个构造函数
    Box(int len  ):_len(len),p(_len),sum(100), eterbox(10)    //   p是引用, 要进行初始化  , 不能直接赋值, 否则出错.
    {
        cout << "I have second constructor" << endl;
    }

    // 实例化一些函数
    int get_len(){return _len;}
    int get_w(){return _w;}
    int get_h(){return _h;}


private:
    int _len;
    int _w;
    int _h;

    // 一定要对引用要初始化  , 通过构造函数的成员列表就可以实现
    int&p;

    // 指针也需要用到 成员列表来初始化
    const int sum;

    Eterbox eterbox;  // 在Box类中实例化另一个类里面的构造函数. eterbox 也要通过成员列表来实现初始化.
};





int main(){

    Box twoparabox(10,20);

    return 0;
}
```



> 1. 一个类里面的构造函数对引用初始化了, 里面的所有的构造函数都要对引用进行初始化.
> 2. 对于 指针来说, 也需要用到成员列表来实现初始化.
> 3. 当一个类里面 要调用另一个类里面的成员函数的时候, 也要通过成员列表来实现初始化.



> 构造函数总结:
>
> 1. 构造一个对象一定会自动调用一个构造函数
> 2. 如果一个类中没有实现默认构造函数, 编译器就会自动生成一个(如果写代码的人没有写带参数的构造函数的话)
> 3. **如果一个类中出现了带参数的构造函数, 那么一定要实现(写)一个无参的构造函数.  因为如果在构造对象时不带参数将无法找到无参的构造函数, 进而导致编译失败.**
> 4. 构造函数可以有多个,根据构造对象时所传递的参数(数量) , 自动调用对应的构造函数
> 5. 类不会占用程序的内存空间, 对象才会占用程序的内存空间.





##### 析构函数

> 析构函数是用来清理成员对象的一个函数. **销毁对象在栈(自动销毁)  和 堆 上所占的内存**
>
> **注意:**
>
> 1. 析构函数只能有一个, 不能有多个;  构造函数可以有多个
>
> 2. 析构函数没有参数也没有任何返回类型的声明
>
> 3. 析构函数在对象销毁时被自动调用
>
>    

``` c++
#include <iostream>
#include <Cstdio>
#include <Cstdlib>
#include <Cstring>


using namespace std;

class Animal
{
public  :                // 注意: 一定要有public , 因为 C++中, 默认是 private, 不写public, 那就是private.

    char *name;
    int age;

    // 下面这个是构造函数
    Animal()
    {
        cout << "I am constructor function" << endl;

        // 下面的两行是在堆上为指针name分配空间的两种方法
        name = (char *)malloc(32);  // 使用malloc为name分配32字节,由于malloc是 void型函数, 所以使用 (char *) 来进行强制转换
        // name = new char[32]

    }

    Animal(const char *namepara){        //xiaohua
    int len;
    len = strlen(namepara);
    name =(char *)malloc(len +1);   // 加上的 1 是为了给字符串里面的字符斜杆预留 1 个字节的空间.

    }


    // 下面这个是 析构函数
    ~Animal()
    {
        cout << "I am xigou function" << endl;

        // 析构函数会自动清楚  栈上的空间,  如果要清除 对象在堆上的空间. 可以如下:
        if (name != NULL)
        free(name) ;  //  如果name不是空指针. 清除name 在 堆上的空间
        // 对于new 那种方法, 可以用  delete [] name; 来删除name在堆上的空间.
    }
};



int main(){
    Animal animal;
    return  0;
}
```

`当类里面有 指针 的时候, 一定要注意是否要使用析构函数了`, 因为指针不仅会在 栈上占用内存,  而且可能会在堆上占用内存. 





##### new 运算符的使用:

用来申请空间的.

```
#include <iostream>
using namespace std;

class Box
{
public :
    int len;
    int w;

    // 无参构造函数
    Box()
    {
        cout << "I am construtor " << endl;
    }

    // 有参构造函数
    Box(int x, int y):len(x),w(y)
    {
        cout << "Box(int x, int y):len(x),w(y) " << endl;
    }

};



int main(){

    // 在 堆上申请一个int类型大小的空间(4 Bytes) , 并将申请的对空间的内容初始化为10
    int *p = new int(10);

   // 在 堆上申请4个int类型大小的空间 (4*sizeof(int)== 16Bytes)  4表示数组长度
   int *p2 = new int[4];

   // 通过指针变量访问空间
   for(int i = 0 ; i < 4 ; i++){
       cout << *(p2 +i ) << endl;  // 还可以写成 cout << p2[i] << endl;
   }

  //  对象到底有没有被创建, 就看类是否调用了构造函数, 如果调用了构造函数, 那么一定被创建了.

   // 在堆上创建一个 Box类型 大小的空间.(实际上Box对象也随之创建了) , 自动调用了 Box()构造函数
   Box *p3 = new Box;

   // 在 堆上创建 4个 Box类型大小的空间.
   Box *p4 = new Box[4];

   // 在堆上创建一个 Box类型 大小的空间 , 调动有参构造函数
   Box *p5 = new Box(10,20);
    return 0;
}
```



##### delete 

> 用来删除对象用的.
>
> 删除单个对象用: delete 对象名
>
> 删除多个对象用: delete [] 对象名



#### new和delete与malloc和free区别

> 为了保持与C语言的兼容,  C++保留了 malloc 和 free . **但是推荐使用  new   和 delete**
>
> 1. new 和 delete 是操作运算符,  而 molloc 和 free是C语言的标准库的函数
> 2. new能自动计算需要分配多少空间, 而malloc 需要手动计算字节数
> 3. new和delete直接带具体类型的指针, 而 malloc 和 free 返回的是void类型的指针
> 4. new类型是安全的, 编译时可以报错,  而 mallloc不是, malloc在某些时候进行的编译, 编译器无法指出
> 5. new调用构造函数, malloc 不会.  delete 调用析构函数, 而 free不会
> 6. new 和 delete是操作符, 所以可以重载. 而 malloc 和 freee则不用.



##### 多个对象的构造和析构

下面的代码可以搞清楚: 一个类在调用另一个类的时候, 创建和删除的顺序

> 1. 创建的时候, 先创建里面被调用的类, 再执行的类
> 2. 删除的时候, 先删除外面正在执行的类, 在删除里面被调用的类.

```C++
#include <iostream>
using namespace  std;

class ABC
{
public:
    ABC(int a, int b , int c)
    {
        cout << "ABC(int a, int b , int c)" << endl;
    }

    ~ABC()
    {
        cout << "~ABC()"  << endl;
    }


private:

    int a;
    int b;
    int c;

};


// 下面这个 MyD类, 调用上面ABC类
class MyD
{
public:
    MyD():abc1(1,2,3) , abc2(4,5,6)
    {
        cout << "MyD()" << endl;
    }

    ~MyD()
    {
        cout << "~MyD()"  << endl;
    }

private:
    ABC abc1;
    ABC abc2;
};


int main(){
    MyD myD;

    return 0;
}

```



##### 使用已构造的对象初始化新的对象

同一段内存空间被多次销毁, 例子和验证如下: 

```c++
#include <iostream>
using  namespace  std;

// 创建一个结构体
class Test
{
public:
    int *sum;
    int a;
    int x;
    int y;

    Test()
    {
        cout << "Test()" << endl;
        x = 0;
        y = 0;
        sum = new int[4];
    }

    Test(int a,int b): x(a) , y(b)
    {
        cout << "Test(int a,int b): x(a) , y(b) " << endl;
    }

    ~Test()
    {
        cout << " ~Test()" << endl;
        delete[] sum;
    }

};


void func(){
    Test *t1 = new Test(10,20);
    Test t2 = *t1;                      // t1, t2 指向的是同一个地址,
                                        // 这意味着, 当t1销毁值, 其中的sum也被销毁. 但它被销毁时. sum指向的内存空间还要再被销毁一次.
                                        // 这就造成了 同一段内存空间, 被多次销毁, 所以 这个函数运行时是不正常的

    cout << "t2.x: " << t2.x << endl;
    cout << "t2.y: " << t2.y << endl;

    cout << "t1.sum: " <<  t1->sum << endl;
    cout << "t2.sum: " << t2.sum << endl;
}


int main(){
    func();
    cout << "正常输出" << endl;  // 这里没有正常输出, 说明func() 没有被正常调用.

    //运行的最后出现的,  Process finished with exit code -1073740940 (0xC0000374)
    //            其中main返回的是   -1073740940  , 而不是0 , 本身就说明main没有被正常调用.

    return 0;   // 如果main返回的不是0 , 那就是异常的.
}
```



**解决方法**

为了避免同一块空间多次销毁, 造成的看不见的异常, 可以有如下三种方法: 

```c++
#include <iostream>
using  namespace  std;

// 创建一个结构体
class Test
{
public:
    int *sum;
    int a;
    int x;
    int y;

    Test()
    {
        cout << "Test()" << endl;
        x = 0;
        y = 0;
        sum = new int[4];
    }

    Test(int a,int b): x(a) , y(b)
    {
        cout << "Test(int a,int b): x(a) , y(b) " << endl;
    }

    ~Test()
    {
        cout << " ~Test()" << endl;
        delete[] sum;
    }

};



int main(){
    Test *t1 = new Test(10,20);
    Test t2 = *t1;

    cout << "t2.x: " << t2.x << endl;
    cout << "t2.y: " << t2.y << endl;

    // 不要将指针赋值, 而应该将所谓的值进行赋值
    for(int i = 0; i<4 ; i++)
    {
        t2.sum[i] = t1->sum[i];
    }

    // 或者直接利用 memcpy
   //  memcpy(t2.sum,t1->sum,4*sizeof(int));

   // 还有一种方法, 也是人们推荐的方法:  用拷贝构造函数来实现.

    cout << "正常输出" << endl;  // 这里没有正常输出, 说明func() 没有被正常调用.

    return 0;
}
```



##### 拷贝构造函数

使用`const` 和引用, 来组成拷贝构造函数 . 

```c++
Test(const Test &t)    // 这是一个拷贝构造函数
    {
        x = t.x;
        y = t.y;
        sum = new int[4];                // 为拷贝对象创建的sum 的新空间
        for (int i = 0 ; i< 4; i++)       // 为拷贝对象赋值.
        {
            sum[i] = t.sum[i];
        }
        cout << "Test(const Test &t)" << endl;
    }
```



所以, 用一个构造好的对象去初始化新的对象, 而避免在清楚成员的时候, 对同一个内存空间多次删除, 可以这样

```c++
#include <iostream>
using  namespace  std;

// 创建一个结构体
class Test
{
public:
    int *sum;
    int a;
    int x;
    int y;

    Test()
    {
        cout << "Test()" << endl;
        x = 0;
        y = 0;
        sum = new int[4];
    }

    Test(int a,int b): x(a) , y(b)
    {
        cout << "Test(int a,int b): x(a) , y(b) " << endl;
        sum = new int[4];  // 一定要调用 指针变量sum, 否则  ~Test() 不会被调用的.
    }


    ~Test()
    {
        cout << " ~Test()" << endl;
        delete[] sum;
    }

    // 自己定义一个拷贝构造函数
    Test(const Test &t)
    {
        x = t.x;
        y = t.y;
        sum = new int[4];                // 为拷贝对象创建的sum 的新空间
        for (int i = 0 ; i< 4; i++)       // 为拷贝对象赋值.
        {
            sum[i] = t.sum[i];
        }
        cout << "Test(const Test &t)" << endl;
    }

};


int main(){
    Test t1(10,20);
    t1.sum[0] = 100;
    t1.sum[1] = 101;
    t1.sum[2] = 102;
    t1.sum[3] = 103;

    Test t3 = t1;

    return 0;
}
```

> **注意:**
>
> 1. 如果自己在写程序的时候没有写拷贝构造函数, 那么编译器会自动的生成一个拷贝构造函数.
>
>    最终实现的是  **简单粗暴的赋值**.
>
> 2. 之所以用  **引用** , 而不是普通的变量, 那是因为我们只需要将构造好的对象传递给我们想要复制的对象, 如果是一个普通的对象, 那么就会在创造一个新的空间, 先存储构造好的对象, 然后再传递给新的对象. 中间过程没必要去创造一个新的空间. 所以为了**避免空间的浪费**, 使用的是 引用. 
>
> 3. 之所以用 **`const`** ,  是为了 **引用** , 防止我们在写拷贝函数的时候, 不小心改变了构造函数里面的一些属性, 造成重新赋值. 



**`深拷贝和浅拷贝`** 的区别

> 主要区别就是是否是  **简单粗暴的赋值**
>
> 1. 在写程序的时候没有编写拷贝函数的情况下, 编译器自己生成的拷贝函数就是**浅拷贝函数** . 说白了就是将 已经生成的对象里面的成员变量, 函数等 全部赋值给 新的对象.
> 2. **深拷贝函数** 就是在写程序的时候 , 自己编写的拷贝函数, 不是简单粗暴的赋值, 还对于一些指针变量进制了重新分配空间地址, 然后再赋值.
>
> **是否使用深拷贝,  就在于  类里面是否有指针变量  ** , 如果 **类里面有指针变量** , 那么 **一定要** 进行深拷贝. 这样可以防止同一块内存空间被多次删除, 造成不易察觉的异常.



> **思考**:
>
> 从**`深度拷贝构造函数的传参`**  可以知道,  在 C++中 , 平常人们在编写函数的时候, 将形参可以设置为 **引用**, 而不是简单普通的变量, 是可以**节省内存**的.  因为如果设置的形参是 普通的变量, 那么在传参的过程中就会先创建空间来储存传入的参数,  而如果形参是引用, 那就没有这一步了.





##### 编译器对属性和方法的处理机制

到现在为止, 我们已经知道了,  在创建一个类的时候, 编译器会自动生成三个函数(如果自己没编写的话) , 它们分别是 **构造函数,  拷贝构造函数 和 析构函数**

C语言中 , "数据" 和"处理和处理数据的函数"  是分开来声明的, 也就是说, 语言本身没有支持  "数据和函数之间的关联" . 在C++ 中, 通过抽象数据类型, (Abstract Data Type , ADT) , 在类中定义数据和函数, 来实现数据和函数直接的绑定.

下面这段代码展示了一个疑问: **函数被存储在哪里**? 

```C++
#include <iostream>
using namespace std;

class C1
{
public:
    int i;
    int j;
    int k;

private:
};

class C2
{
public:
    int _i;
    int _j;
    int _k;

private:
    int get_k(){return _k;}
    void set_k(int val){ _k = val;}

};



int main(){
    C1 c1;
    C2 c2;
    cout << sizeof(c1) << endl;
    cout << sizeof(c2) << endl;

    // 运行结构发现, 构造的两个对象大小相等,
    // 其实对应着 3个变量 每个变量4个字节, 所以一共12个字节
    // 那么  函数占用的内存呢?
    
    return 0;
}
```

实际上, C++的内存处理方法是个 **四区模型** , 下面是我在网上的找到的参考文章:

https://www.cnblogs.com/andyniu/p/7632608.html





##### this指针

```c++
#include <iostream>
using namespace std;

class C2
{
public:
    int  i;
    int j;
    int  k;
    int get_k(){return k;}
    void set_k(int val){ k = val;}

private:

};


int main(){
    C2 c2;
    
    cout << c2.k << endl;
    cout << c2.get_k() << endl;
    //  上面两行 放回的都是 k , 编译器是怎么区分出来的呢?

    return 0;
}
```

为了调试程序, 先生成一个可执行文件` main.exe`

```
g++ -g main.cpp -o main
```

用gdb调试程序: 

```
gdb main 
```

```
start
```

输入 `n`  , 表示执行下一句

输入 `print c2.get_k` 打印 `get_k` 方法 , 此时可以看到 `(const *)`   , 这个就是编译器自己生成的 `this 指针`



再例如:

```c++
class A
{
public:
		int x;
		int y;
		int z;
    ABC(ABC *const this , int x,int y ,int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }

}
```





##### 静态成员变量

通过关键词 `static`, 来声明**类**的静态成员, 静态成员提供了一个 **同类对象共享的机制** ,  也就是说, 只要被创建的对象使用的是同一个类, 那么不管这个对象是什么, 它们都可以对写在那个类里面的静态成员进行操作. 

```c++
#include <iostream>
using namespace std;

int cnt = 0;

class Sheep
{
public:
    char name[10];
    int age;
    static  int cnt;    // 声明静态成员变量,   但是静态成员变量不是类的成员变量, 只是写在类里面
                              //  作用域是 类里面 和 类的所有的对象

    Sheep()
    {
        cnt ++ ;  // 每次访问构造函数的时候, cnt 都要 加 一
    }

    ~Sheep()
    {
        cnt --;
    }


};

// 定义类里面声明的静态成员边浪
int Sheep::cnt = 0 ;      // 如果直接写 int Sheep::cnt;  也是默认的 0


int main(){
    Sheep *p = new Sheep[10];      // 调用了10次, 所以 加10
    cout << Sheep::cnt << endl;
    Sheep s1;                      // 又调用了一次, 所以 加1 , 变为 11
    cout << Sheep::cnt << endl;
    Sheep s2;                       // 再加一 , 变为 12
    cout << s1.cnt << endl;           // 12
    cout << s2.cnt << endl;             // 12


    return 0;
}
```





##### 静态成员函数

使用`static` 修饰的成员函数叫做静态成员函数.

> 1. 在实际中推荐 **使用类访问静态成员变量和静态成员函数**
> 2. 静态成员函数**只能使用静态成员变量**, 不能使用其他的变量. 静态成员函数之所以无法访问除静态成员变量意外的其他变量, 是因为静态成员函数没有使用 **this 指针** , 而类里面普通的成员函数, 都默认使用了 **this指**

例子如下:

```c++
#include <iostream>
using namespace std;

int cnt = 0;

class Sheep
{
public:
    char name[10];
    int age;
    static  int cnt;    // 声明静态成员变量,   但是静态成员变量不是类的成员变量, 只是写在类里面
                              //  作用域是 类里面 和 类的所有的对象

    static int sheep_num()
    {
        return cnt ;   // 访问静态成员变量.
    }

    Sheep()
    {
        cnt ++ ;  // 每次访问构造函数的时候, cnt 都要 加 一
    }

    ~Sheep()
    {
        cnt --;
    }

private:

};

// 定义类里面声明的静态成员边浪
int Sheep::cnt = 0 ;      // 如果直接写 int Sheep::cnt;  也是默认的 0

int main(){
    Sheep *p = new Sheep[10];

    // 在实际中推荐用下面两种方式访问静态成员变量和静态成员函数.
    cout << Sheep::cnt << endl;           // 访问静态成员变量
    cout << Sheep::sheep_num() << endl;    // 访问静态成员函数
    return 0;
}
```

> **静态成员函数的作用**:
>
> 1. 通过静态成员函数可以获取存储在 **private** 中的, 静态成员变量
> 2. 静态成员函数可以实现某些特殊的设计模式. 例如: Singleton(单例模式)
> 3. 可以封装某些算法, 例如: 数学函数sin, cos, tan 等. 这些函数根本需要对象的实例化, 要用的时候直接调用就行. 











#### 继承







#### 多态







# 学习使得注意点

1. 学习的时候, 不要多次构造同名的类, 否则编译器可能会不识别, 最终报错, 最好学习一个知识点, 创建一个项目, 或者删除一些自己写的文件
2. 



