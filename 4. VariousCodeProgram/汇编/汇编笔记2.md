# 汇编程序的编写

## 程序编写流程

1. 编写汇编源程序

2. 对程序进行**编译连接**, 这样就可以生成在操作系统中运行的可执行的文件.

   > 可执行文件包括:  
   >
   > 1. 位于上半部分的 相关描述信息(例如: 程序的大小, 占用的内存)
   > 2. 程序和数据(包括汇编语言翻译过来的**机器码**和**源程序中定义的数据**.)

3. 执行可执行文件, 操作系统将可执行文件中的 **机器码和数据加载入内存.初始化后, 由电脑的CPU执行**

# 编写源程序

> 指令:
>
> 1. 汇编指令:  指的是被CPU执行的机器码.
> 2. 伪指令: 不会被CPU执行, 最终被编译器执行



```
; 分号在汇编语言中表示 注释
mytest segment
			 mov ax,2
			 add ax,ax
			 add ax,ax
			 
			 mov ax,4C00H
			 int 21H
abc ends
end
; 这个就是一个asm文件的内容啦
```

> 暂略

# 连接程序

> 暂略

# 调试程序

> 暂略

# 汇编指令

## mov 指令

> 作用: 把一个字或者字节的操作数从原地址传送到目的地址

```
;格式例如: mov target ,source

;示例
mov reg/mem,imm           ;mem表示内存memory   , imm 表示立即数(数据) , seg表示寄存器
mov reg/mem/seg,reg
mov reg/seg,mem
mov reg/mem,seg

; 以mov reg/mem, seg 为例, 意思是:
; 将 seg中的数据传送到 reg 或者 mem中
```

​	**注意:**

1. target 不能是 CS(代码寄存器), 例如: `mov cs,ax `是不被允许的
2. target 和 source 不能同时为内存数, 寄存器(包括:CS,DS,ES,SS,FS,GS), 例如:`mem,mem`这种是不被允许的
3. 不能把 **立即数**直接传给 **段寄存器**
4. target 和 source 必须类型匹配, 比如, 要么都是字节, 要么都是双字等
5. **`由于立即数没有没缺的类型, 所以在将立即数传送到target时, 系统会自动将立即数零扩展到与target数的维数相同, 在进行传送, 有时候需要用BYTE PTR, WORD PTR明确立即数的位数`**



```
debug
r
a
mov al,4
t
a
mov cx,1010
a
mov ax,bx
mov byte ptr [si],0ah   ;byteptr说明是字节操作. 
r
ds073f:0000
t
d073f:0000
r
a
mov ds,ax
t
a
mov ax,073f
mov ds,ax
t
a
mov [si],al
d073f:0000
t
d073f:0000
```

# xchg指令

>  作用: 将一个自己或者自己的源操作数和目的操作数想交换

```
;使用格式
; xchg oprd1 ,oprd2
;例如:
xchg reg,reg  ; 这一点很重要, xchg可以交换两个寄存器的数据
xchg reg,mem
xchg mem,reg
```

```
;示例:
xchg al,cl
r
t
xchag ax,[bx]
r
t
xchag [bx],ax
r
t
```

​		**注意事项:**

1. 不能同时都是内存操作
2. 任何寄存器都不能为段起存器
3. 任何操作都不能是立即数
4. 两个操作数的长度必须相等

## xlat

> 作用: 将bx指定的缓冲区、AL指定的位移处的一个字节数据取出赋值给AL

```
;格式
xlat    ;al<-ds:[bx+al]   [bx+al]:整体作为偏移地址，al作为地址位移

;示例:
r
a
mov bx,0100H
mov al,03H
xlat             ;al<-ds:[0100+03]H

```



## push 和 pop

> 作用: 将寄存器或者存储器中的数据按照堆栈规则进行入栈和出栈

```
;使用格式
;push 源操作数
;pop  目的操作数
push reg\mem\seg
pop  reg\mem\seg


;示例
push ax       ; 将ax寄存器中的数据压入到栈中
pop ax        ; 将栈顶的数据出栈到ax中

```

**注意:**

1. 当栈为空时能不进行出栈
2. 指令的操作数必须是16位，即不能使用al这种8位寄存器



## lea , lds , les

> 作用: 将对应的地址表示送入对应的寄存器中

```
;格式
lea reg,mem
lds reg,mem
les reg,mem

;示例:
mov bx,0400H
mov si,3CH
lea bx,[bx+si+0f62h]
;bx = 0400H + 003CH+0f62H = 139 EH

;作用:
;LDS：将mem指定的字送入指定的寄存器中，并且DS=mem+2
;LES：将mem指定的字送入指定的寄存器中，并且ES=mem+2
```



## LAHF、SAHF、PUSHF、POPF(标志寄存器指令)

> **`标志寄存器`**：用来存储相关指令的某些执行结果，用来为CPU执行相关指令提供依据并可以以此来
>
> 控制CPU的相关行为。8086中的标志寄存器为PSW（程序状态字）。该寄存器并不是用来存放普通
>
> 数据的，而是按位起作用，每一位都有专门的含义。（如下图）
>
> SF：符号标志位，如果执行结果为负数，则SF=1，非负则SF=0；
>
> ZF：零标志位，如果执行结果为0，则ZF=1，否则ZF=0；
>
> PF：奇偶标志位，如果执行结果中所有二进制位中1的个数为偶数则PF=1，否则PF=0；
>
> CF：进/借位标志位，一般来说，在进行无符号的运算时，如果数据最高位产生了
>
> 进位或者借位CF=1，否则CF=0；
>
> OF：溢出标志位，运算结果超出了机器所能表示的范围称为溢出；
>
> DF：方向标志位，在串处理指令操作后控制DI、SI的增减，如果DF=0，则前述寄存器递增，
>
> 否则递减，注意DF的值由程序员通过CLD（0）和STD（1）指令设定；
>
> TF：调试标志位，当TF=1时，处理器每次只执行一条指令，即单步执行；
>
> IF：中断允许标志位，用来控制8086CPU是否可以接受外部中断请求。IF=1，则能响应外部中断，
>
> 否则屏蔽外部中断；
>
> AF：辅助进位标志位，运算过程中看第三位，不论长度多少。如果最后四位向前有进位/借位
>
> ，AF=1，否则AF=0；

> **PSW程序状态字寄存器**
>
> 1. PSW寄存器也成FLAGS寄存器. 其中 1, 3, 5 , 12 , 13 , 14  15位在 8086CPU没有使用, 不具有任何含义, 其余都有特殊含义
>
> 2. 在DEBUG中, 每个状态为都被单独的显示, 标志位为 `是`或者 `否`





```
;使用格式 直接输入即可
;低8位传送
LAHF ;将标志寄存器的低字节传送给寄存器AH
     ;SF/ZF/AF/PF/CF状态标志位分别送入AH的第7/6/4/2/0位，而AH的第5/3/1位任意
SAHF ;SAHF将AH寄存器内容送FLAGS的低字节
     ;用AH的第7/6/4/2/0位相应设置SF/ZF/AF/ PF/CF标志
;16位传送
PUSHF ;PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2
POPF  ;POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2

```



